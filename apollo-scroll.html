<link rel="import" href="../polymer/polymer-element.html">

<dom-module id="apollo-scroll">
  <template>
    <style>
      :host {
        display: block;
      }

      #container {
        height:300px;
        width:100%;
        overflow: scroll;
      }

      #content {
        background: turquoise;
      }

      #top {
       height: 0;
      }
      #bottom {
        background-color: violet;
      }
      .rows {
        
      }
      .row {
        white-space: nowrap;
        font-size:0;
      }
      
      .row.special {
        background-color: goldenrod;
      }
      .cell {
        width:150px;
        display:inline-block;
        margin: -1px 0 0 -1px;
        padding: 4px;
        border:1px solid gray;
        font-size: 14px;
      }
    </style>
    <div id="container">
        <div id="top"></div>
        <div id="content">
          <div id="rows">
            <template is="dom-repeat" items="{{rows}}">
              <div class$="row [[_getRowClass(item.special)]]">
                  <template is="dom-repeat" items="{{item.data}}">
                    <div class="cell">{{item}}</div>
                  </template>
              </div>
            </template>
          </div>
        </div>
        <div id="bottom"></div>
    </div>
    <h2>Hello [[prop1]]!</h2>
  </template>

  <script>
    /**
     * `apollo-scroll`
     * 
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class ApolloScroll extends Polymer.Element {
      static get is() { return 'apollo-scroll'; }
      static get properties() {
        return {
          currentScrollPosition: {
            type: Number,
            value: 0
          },
          rendering: {
            type: Boolean,
            valeue: false
          },
          dataIndex: {
            type: Number,
            value: 0
          },
          dataLenght: {
            type: Number,
            value: 10
          },
          fullHeight: {
            type: Number,
            value: 1000
          },
          oneRowHeight: {
            type: Number,
            value: 0
          },
          rows: {
            type: Array,
            notify: true,
            value: function() { return []; }
          }
        };
      }
      constructor() {
        super();
        this._getInitialData();
        // When possible, use afterNextRender to defer non-critical
        // work until after first paint.
        Polymer.RenderStatus.afterNextRender(this, function() {
          this._loadInitialData();
          this.$.container.addEventListener('scroll', (evt) => {
            this._onScroll()
          }, {
            capture: true,
            passive: true
          })
        });
      }
      _getRowClass(special) {
        console.log("in class function");
        return special ? "special" : "row";
      }

      _loadInitialData(){
        const tenRowsHeight = this.$.rows.offsetHeight;
        this.oneRowHeight = tenRowsHeight / 10;
        const viewportHeight = this.$.container.offsetHeight;
        const neededRowAmounts = Math.ceil(viewportHeight / this.oneRowHeight * 3);
        const rowCount = this._getCount();
        this.fullHeight = rowCount * this.oneRowHeight;
        this._appendRows(10,neededRowAmounts-10);
        this.dataLenght=35;
        this.$.bottom.style.height = this.fullHeight- (this.$.content.offsetHeight) + "px" ;
      }
      
      _onScroll() {
        this.currentScrollPosition = this.$.container.scrollTop;
        const that = this;
        if(!this.rendering){
          Polymer.Async.animationFrame.run(function(){
            that._update();
          },100);
        }
        this.rendering = true;
      }

      _update(){
        // calculate all the breakpoints and heights
        const viewportTop = this.$.container.scrollTop;
        const viewportHeight = this.$.container.offsetHeight;
        const renderedRowsTop = this.$.top.offsetHeight;
        const renderedRowsHeight = 3*viewportHeight;
        const shiftUpwardsBreakpoint = renderedRowsTop + 0.5*viewportHeight;
        const shiftDownwardsBreakpoint = renderedRowsTop + 2.5*viewportHeight;      
        

       
        if(this.currentScrollPosition<shiftUpwardsBreakpoint){
           // scroll upwards if above upward breakpoint
          this._shiftUpwards(renderedRowsTop,renderedRowsHeight,viewportHeight);
          // Prohibit extra scroll events that would make this code run amok.
          this.$.container.scrollTop = this.currentScrollPosition;
        } else if(this.currentScrollPosition+viewportHeight>shiftDownwardsBreakpoint){
          // scroll downwards if below downwards breakpoint
          this._shiftDownwards(renderedRowsTop,renderedRowsHeight,viewportHeight);
          // Prohibit extra scroll events that would make this code run amok.
          this.$.container.scrollTop = this.currentScrollPosition;
        }
        this.rendering = false;
      }

      _shiftUpwards(renderedRowsTop,renderedRowsHeight,viewportHeight){
        let newRenderedRowsTop = renderedRowsTop-viewportHeight;
        if(newRenderedRowsTop<0){
          newRenderedRowsTop = 0;
        }
        this._shiftRows(newRenderedRowsTop, renderedRowsHeight);
          
        const rowsBeforeNewTop = Math.floor(newRenderedRowsTop / this.oneRowHeight);
        const rowsInRange = Math.ceil(renderedRowsHeight / this.oneRowHeight);
        this._loadData(rowsBeforeNewTop, rowsInRange);
      }

      _shiftDownwards(renderedRowsTop,renderedRowsHeight,viewportHeight){
        let newRenderedRowsTop = renderedRowsTop+viewportHeight;
          if(newRenderedRowsTop>this.fullHeight-3*viewportHeight){
            newRenderedRowsTop = this.fullHeight-3*viewportHeight;
          }
          
          //TODO: Shift with a few pixels to make the row placements match.
          this._shiftRows(newRenderedRowsTop, renderedRowsHeight);
          
          const rowsBeforeNewTop = Math.floor(newRenderedRowsTop / this.oneRowHeight);
          const rowsInRange = Math.ceil(renderedRowsHeight / this.oneRowHeight);
          this._loadData(rowsBeforeNewTop, rowsInRange);
      }

      _shiftRows(top, renderedRowsHeight){
        this.$.top.style.height = top + "px";
        console.log(this.$.content.offsetHeight);
        this.$.bottom.style.height = this.fullHeight- (top + this.$.content.offsetHeight) + "px" ;
      }

      _loadData(start, amount){
        // TODO: optimize. Now it throws out everything and starts over.
        // 1. remove items with index before start
        // 2. append items with index between this.rows last and start+amount
        console.log("requesting rows: " + start + "-" + (start+amount));
        const rows = [];
        for(let index = start; index < start + amount; index++){
          const row = this._getRow(index);
          rows.push(row);
        }
        this.rows = rows;
       
      }

      _getInitialData(){
        const rows = [];
        for(let index = 0; index < 10; index++){
          const row = this._getRow(index);
          rows.push(row);
        }
        this.rows = rows;
      }

      _appendRows(start, amount){
        for(let index = start; index < start + amount; index++){
          const row = this._getRow(index);
          this.push('rows', row);
          
          //this.rows.push(row);
          //this.notifyPath("rows");
        }
      }

      _getRow(index){
        const row = {};
        row.index = index;
        row.data = [];
        for(let column = 0; column < 20; column++){
          row.data[column] = "Row " + (index+1) +", Column " + (column+1);
        }
        if(index%8 == 0){
          row.special = true;
        }
        return row;
      }

      _getCount(){
        return 412;
      }
    }

    window.customElements.define(ApolloScroll.is, ApolloScroll);
  </script>
</dom-module>
